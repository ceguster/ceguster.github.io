<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Always the Programmer, Never the Program]]></title>
  <link href="http://ceguster.github.io/atom.xml" rel="self"/>
  <link href="http://ceguster.github.io/"/>
  <updated>2014-10-26T21:59:12-04:00</updated>
  <id>http://ceguster.github.io/</id>
  <author>
    <name><![CDATA[Chelsea Guster]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Regex, the Great & Powerful]]></title>
    <link href="http://ceguster.github.io/blog/2014/10/09/blog-1/"/>
    <updated>2014-10-09T19:29:29-04:00</updated>
    <id>http://ceguster.github.io/blog/2014/10/09/blog-1</id>
    <content type="html"><![CDATA[<p>This week, I discovered a couple of things about regular expressions, or regexes, that reminded me of some bigger themes and lessons in programming.</p>

<p><strong>First, it is possible to have glorious moments of mind-meld with your machine when what you mean, what you type, and what the computer understands are all the same.</strong> I encountered a moment of regex understanding like this with a lab entitled Phone Number Formatter, which asked us to take in any 10-digit string and produce a nicely formatted telephone number, such as (123) 456-7890. Looking at the test spec for the lab, I saw I needed to allow for the given number to be presented in a variety of ways, ranging from unformatted, with no spaces or punctuation, to partially formatted, with one dash or parentheses around the leading 3 digits. Given this variation, I chose first to normalize the argument I would be given, by globally substituting in nil for any spaces or punctuation already in the number.</p>

<figure class='code'><figcaption><span>normalize_phone_number.rb</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="k">def</span> <span class="nf">normalize_phone_number</span><span class="p">(</span><span class="n">num</span><span class="p">)</span>
</span><span class='line'>  <span class="n">reg_num</span> <span class="o">=</span> <span class="n">num</span><span class="o">.</span><span class="n">to_s</span><span class="o">.</span><span class="n">gsub</span><span class="p">(</span><span class="sr">/[\s()-]/</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>Secondly, I want to standardize the output of the method, by placing parentheses around the first 3 digits, followed by a space, followed by 3 more, then a dash, then the final four. Shockingly, I found that regex can think this way too, by using what is known as <a href = "http://www.ruby-doc.org/core-2.1.3/Regexp.html">capturing</a>, or creating distinct groups within the larger regular expression that can be referred back to by their group name or number (but not both).</p>

<figure class='code'><figcaption><span>normalize_phone_number.rb</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="k">def</span> <span class="nf">normalize_phone_number</span><span class="p">(</span><span class="n">num</span><span class="p">)</span>
</span><span class='line'>  <span class="n">reg_num</span> <span class="o">=</span> <span class="n">num</span><span class="o">.</span><span class="n">to_s</span><span class="o">.</span><span class="n">gsub</span><span class="p">(</span><span class="sr">/[\s()-])/</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">)</span>
</span><span class='line'>  <span class="n">tel_num</span> <span class="o">=</span> <span class="n">reg_num</span><span class="o">.</span><span class="n">to_s</span><span class="o">.</span><span class="n">sub</span> <span class="sr">/(\d{3})(\d{3})(\d{4})/</span><span class="p">,</span> <span class="s1">&#39;(\1) \2-\3&#39;</span>
</span><span class='line'>  <span class="n">tel_num</span>
</span><span class='line'><span class="k">end</span>
</span></code></pre></td></tr></table></div></figure>


<p>This construct allowed me to do something in my code that feels very linguistically natural in English: I could say &ldquo;the first 3 numbers&rdquo;, &ldquo;the next 3 numbers&rdquo;, and &ldquo;the next 4 numbers&rdquo; to a computer and be understood. Awesome.</p>

<p><strong>Another lesson in programming that regexes reminded me of is: don&rsquo;t over-program.</strong> I was reminded of this during a lab entitled &ldquo;Regex Rally,&rdquo; in which we had to write the correct regular expression directly into the spec file to make the tests pass. By looking at the third test, which was asking for a regex that matches a valid email address. Working with <a href="http://www.rubular.com">Rubular</a>, I built an expression that matched standard email addresses (name@domain.***), but ran into trouble with emails where the @ was preceded by a string that contained periods, or where the domain was, for example, &ldquo;@co.uk,&rdquo; instead of &ldquo;.com.&rdquo; I found an expression that allowed those variations&hellip;but it failed to weed out unacceptable inputs, like &ldquo;name@<a href="&#109;&#x61;&#x69;&#x6c;&#116;&#x6f;&#x3a;&#x65;&#120;&#x61;&#109;&#x70;&#108;&#x65;&#x2e;&#x63;&#x6f;&#x6d;&#64;&#101;&#120;&#97;&#109;&#112;&#x6c;&#x65;&#46;&#99;&#x6f;&#109;&#x2e;">&#x65;&#x78;&#97;&#x6d;&#112;&#x6c;&#101;&#x2e;&#x63;&#x6f;&#x6d;&#x40;&#x65;&#x78;&#97;&#109;&#112;&#x6c;&#101;&#46;&#99;&#x6f;&#109;&#46;</a>&rdquo;</p>

<p>I worked on Rubular for a little while, but was having trouble weeding out all the edge cases (and beginning to feel a little crazy). Then I realized &ndash; I was writing a regular expression to allow certain characters in a certain relational order, but what I really needed was a regex that <em>disallowed</em> the undesirables. I came up with the following.</p>

<figure class='code'><figcaption><span>regex_rally_spec.rb</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="n">it</span> <span class="s2">&quot;matches valid email address&quot;</span> <span class="k">do</span>
</span><span class='line'>    <span class="n">my_regex</span> <span class="o">=</span> <span class="sr">/\A[^@\s]+@([^@\s]+\.)+[^@\s]+\z/</span>
</span></code></pre></td></tr></table></div></figure>


<p>Read in plain English, this says something like, &ldquo;Find the strings that start with any word characters except @ and whitespace, followed by one @, followed by any word characters except @ and whitespace, but including one period, followed by any word characters except @ and whitespace, at which point, the string will end.&rdquo; (In this instance, I find the regex to be the somewhat more eloquent means of communicating intent). This expression allowed the test to pass, and reminded me not to overthink things; if you what you don&rsquo;t want to find, build against that, and not for all other possibilities.</p>

<p>With that concludes my brief salute to the Regular Expression, which I&rsquo;ve started to see as a microcosm of the programming universe unto itself. Thanks for reminding me of things I should know.</p>
]]></content>
  </entry>
  
</feed>
